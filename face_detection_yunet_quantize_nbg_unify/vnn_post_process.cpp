/****************************************************************************
*   Generated by ACUITY 6.21.1
*   Match ovxlib 1.1.30
*
*   Neural Network appliction post-process source file
****************************************************************************/
/*-------------------------------------------
                Includes
-------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "vsi_nn_pub.h"

#include "vnn_global.h"
#include "vnn_post_process.h"

#include <opencv2/opencv.hpp>

#define _BASETSD_H

using namespace cv;
using namespace std;

/*-------------------------------------------
                  Variable definitions
-------------------------------------------*/

/*{graph_output_idx, postprocess}*/
const static vsi_nn_postprocess_map_element_t* postprocess_map = NULL;


/*-------------------------------------------
                  Functions
-------------------------------------------*/
static void save_output_data(vsi_nn_graph_t *graph)
{
    uint32_t i;
#define _DUMP_FILE_LENGTH 1028
#define _DUMP_SHAPE_LENGTH 128
    char filename[_DUMP_FILE_LENGTH] = {0}, shape[_DUMP_SHAPE_LENGTH] = {0};
    vsi_nn_tensor_t *tensor;

    for(i = 0; i < graph->output.num; i++)
    {
        tensor = vsi_nn_GetTensor(graph, graph->output.tensors[i]);
        vsi_nn_ShapeToString( tensor->attr.size, tensor->attr.dim_num,
            shape, _DUMP_SHAPE_LENGTH, FALSE );
        snprintf(filename, _DUMP_FILE_LENGTH, "output%u_%s.dat", i, shape);
        vsi_nn_SaveTensorToBinary(graph, tensor, filename);

    }
}

static vsi_bool get_top
    (
    float *pfProb,
    float *pfMaxProb,
    vsi_size_t *pMaxClass,
    vsi_size_t outputCount,
    vsi_size_t topNum
    )
{
    vsi_size_t i, j, k;

    #define MAX_TOP_NUM 20
    if (topNum > MAX_TOP_NUM) return FALSE;

    memset(pfMaxProb, 0xfe, sizeof(float) * topNum);
    memset(pMaxClass, 0xff, sizeof(vsi_size_t) * topNum);

    for (j = 0; j < topNum; j++)
    {
        for (i=0; i<outputCount; i++)
        {
            for (k=0; k < topNum; k ++)
            {
                if(i == pMaxClass[k])
                    break;
            }

            if (k != topNum)
                continue;

            if (pfProb[i] > *(pfMaxProb+j))
            {
                *(pfMaxProb+j) = pfProb[i];
                *(pMaxClass+j) = i;
            }
        }
    }

    return TRUE;
}

static vsi_status show_top5
    (
    vsi_nn_graph_t *graph,
    vsi_nn_tensor_t *tensor
    )
{
    vsi_status status = VSI_FAILURE;
    vsi_size_t i,sz,stride;
    float *buffer = NULL;
    uint8_t *tensor_data = NULL;
    vsi_size_t MaxClass[5];
    float fMaxProb[5];
    vsi_size_t topk = 5;

    sz = 1;
    for(i = 0; i < tensor->attr.dim_num; i++)
    {
        sz *= tensor->attr.size[i];
    }

    if(topk > sz)
        topk = sz;

    stride = (vsi_size_t)vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    if(stride == 0)
    {
        stride = 1;
    }
    tensor_data = (uint8_t *)vsi_nn_ConvertTensorToData(graph, tensor);
    buffer = (float *)malloc(sizeof(float) * sz);

    for(i = 0; i < sz; i++)
    {
        status = vsi_nn_DtypeToFloat32(&tensor_data[stride * i], &buffer[i], &tensor->attr.dtype);
    }

    if (!get_top(buffer, fMaxProb, MaxClass, sz, topk))
    {
        printf("Fail to show result.\n");
        goto final;
    }

    printf(" --- Top%d ---\n", topk);
    for(i = 0; i< topk; i++)
    {
        printf("%3d: %8.6f\n", MaxClass[i], fMaxProb[i]);
    }
    status = VSI_SUCCESS;

final:
    if(tensor_data)vsi_nn_Free(tensor_data);
    if(buffer)free(buffer);
    return status;
}

cv::Mat visualize(const cv::Mat& image, const cv::Mat& faces, float fps = -1.f)
{
    static cv::Scalar box_color{0, 255, 0};
    static std::vector<cv::Scalar> landmark_color{
        cv::Scalar(255,   0,   0), // right eye
        cv::Scalar(  0,   0, 255), // left eye
        cv::Scalar(  0, 255,   0), // nose tip
        cv::Scalar(255,   0, 255), // right mouth corner
        cv::Scalar(  0, 255, 255)  // left mouth corner
    };
    static cv::Scalar text_color{0, 255, 0};

    auto output_image = image.clone();

    if (fps >= 0)
    {
        cv::putText(output_image, cv::format("FPS: %.2f", fps), cv::Point(0, 15), cv::FONT_HERSHEY_SIMPLEX, 0.5, text_color, 2);
    }

    for (int i = 0; i < faces.rows; ++i)
    {
        // Draw bounding boxes
        int x1 = static_cast<int>(faces.at<float>(i, 0));
        int y1 = static_cast<int>(faces.at<float>(i, 1));
        int w = static_cast<int>(faces.at<float>(i, 2));
        int h = static_cast<int>(faces.at<float>(i, 3));
        cv::rectangle(output_image, cv::Rect(x1, y1, w, h), box_color, 2);

        // Confidence as text
        float conf = faces.at<float>(i, 14);
        cv::putText(output_image, cv::format("%.4f", conf), cv::Point(x1, y1+12), cv::FONT_HERSHEY_DUPLEX, 0.5, text_color);
#if 1
        // Draw landmarks
        for (int j = 0; j < landmark_color.size(); ++j)
        {
            int x = static_cast<int>(faces.at<float>(i, 2*j+4)), y = static_cast<int>(faces.at<float>(i, 2*j+5));
            cv::circle(output_image, cv::Point(x, y), 2, landmark_color[j], 2);
        }
#endif
    }
    return output_image;
}

static float* vmx_CopyTensorToBuffer
    (
    vsi_nn_graph_t *graph,
    vsi_nn_tensor_t *tensor
    )
{
    vsi_status status = VSI_FAILURE;
    vsi_size_t i, sz, stride;
    float *buffer = NULL;
    uint8_t *tensor_data = NULL;

    sz = 1;
    for(i = 0; i < tensor->attr.dim_num; i++)
    {
        sz *= tensor->attr.size[i];
    }
    // printf("[%s()]::[%d] sz = %d\n", __FUNCTION__, __LINE__, sz);

    stride = (vsi_size_t)vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    if(stride == 0)
    {
        stride = 1;
    }
    tensor_data = (uint8_t *)vsi_nn_ConvertTensorToData(graph, tensor);
    buffer = (float *)malloc(sizeof(float) * sz);

    for(i = 0; i < sz; i++)
    {
        status = vsi_nn_DtypeToFloat32(&tensor_data[stride * i], &buffer[i], &tensor->attr.dtype);
    }
    
    return buffer;
}

vsi_status vnn_PostProcess
    (
    vsi_nn_graph_t *graph,
    const char **inputs,
    uint32_t input_num
    )
{
    vsi_status status = VSI_FAILURE;
    vsi_nn_tensor_t *tensor;
    float *data = NULL;
    std::vector<float*> output_blobs;
    uint32_t i;

    printf("[%s()]::[%d] \n", __FUNCTION__, __LINE__);
    printf("[%s()]::[%d] graph->output.num = %ld\n", __FUNCTION__, __LINE__, graph->output.num);
    // status = show_top5(graph, vsi_nn_GetTensor(graph, graph->output.tensors[0]));

    /* Save all output tensor data to txt file */
    // save_output_data(graph);

    for (i = 0; i < graph->output.num; i++)
    {
        tensor = vsi_nn_GetTensor(graph, graph->output.tensors[i]);
        // status = show_top5(graph, tensor);

        if (tensor) {
            // uint32_t tensor_bytes = vsi_nn_GetTensorSize(
            //     tensor->attr.size, tensor->attr.dim_num, tensor->attr.dtype.vx_type);
            // uint32_t tensor_bytes = 1;
            // for(int idx = 0; idx < tensor->attr.dim_num; idx++)
            // {
            //     tensor_bytes *= tensor->attr.size[idx];
            // }

            // printf("[%s()]::[%d] tensor_bytes[%d] = %d\n", __FUNCTION__, __LINE__, i, tensor_bytes);

            data = vmx_CopyTensorToBuffer(graph, tensor);
            output_blobs.push_back(data);
        }
    }
    printf("[%s()]::[%d] output_blobs.size = %ld\n", __FUNCTION__, __LINE__, output_blobs.size());

#if 1
    int inputW;
    int inputH;
    int padW;
    int padH;
    const int divisor = 32;
    int topK = 5000;
    float scoreThreshold = 0.9f;
    float nmsThreshold = 0.3f;
    const std::vector<int> strides = {8, 16, 32}; //{8, 16, 32}

    inputW = 640;
    inputH = 640;

    padW = (int((inputW - 1) / divisor) + 1) * divisor;
    padH = (int((inputH - 1) / divisor) + 1) * divisor;

    cv::Mat faces;
    for (size_t i = 0; i < strides.size(); ++i) {
        int cols = int(padW / strides[i]);
        int rows = int(padH / strides[i]);
        // printf("[%s()]::[%d] cols = %d ; rows = %d\n", __FUNCTION__, __LINE__, cols, rows);

        float* cls_v = output_blobs[i];
        float* obj_v = (output_blobs[i + strides.size() * 1]);
        float* bbox_v = (output_blobs[i + strides.size() * 2]);
        float* kps_v = (output_blobs[i + strides.size() * 3]);

        printf("[%s()]::[%d] \n", __FUNCTION__, __LINE__);

        // (tl_x, tl_y, w, h, re_x, re_y, le_x, le_y, nt_x, nt_y, rcm_x, rcm_y, lcm_x, lcm_y, score)
        // 'tl': top left point of the bounding box
        // 're': right eye, 'le': left eye
        // 'nt':  nose tip
        // 'rcm': right corner of mouth, 'lcm': left corner of mouth
        Mat face(1, 15, CV_32FC1);

        for(int r = 0; r < rows; ++r) {
            for(int c = 0; c < cols; ++c) {
                size_t idx = r * cols + c;

                // Get score
                float cls_score = cls_v[idx];
                float obj_score = obj_v[idx];

                // Clamp
                cls_score = MIN(cls_score, 1.f);
                cls_score = MAX(cls_score, 0.f);
                obj_score = MIN(obj_score, 1.f);
                obj_score = MAX(obj_score, 0.f);
                float score = std::sqrt(cls_score * obj_score);
                face.at<float>(0, 14) = score;

                // Checking if the score meets the threshold before adding the face
                if (score < scoreThreshold)
                    continue;
                
                // Get bounding box
                float cx = ((c + bbox_v[idx * 4 + 0]) * strides[i]);
                float cy = ((r + bbox_v[idx * 4 + 1]) * strides[i]);
                float w = exp(bbox_v[idx * 4 + 2]) * strides[i];
                float h = exp(bbox_v[idx * 4 + 3]) * strides[i];

                float x1 = cx - w / 2.f;
                float y1 = cy - h / 2.f;

                face.at<float>(0, 0) = x1;
                face.at<float>(0, 1) = y1;
                face.at<float>(0, 2) = w;
                face.at<float>(0, 3) = h;

                // Get landmarks
                for(int n = 0; n < 5; ++n) {
                    face.at<float>(0, 4 + 2 * n) = (kps_v[idx * 10 + 2 * n] + c) * strides[i];
                    face.at<float>(0, 4 + 2 * n + 1) = (kps_v[idx * 10 + 2 * n + 1]+ r) * strides[i];
                }
                faces.push_back(face);
                // printf("[%s()]::[%d] idx: %d\n", __FUNCTION__, __LINE__, (int)idx);
            }
        }
    }
    printf("[%s()]::[%d] obj detected: %d\n", __FUNCTION__, __LINE__, faces.rows);
    Mat nms_faces;
    if (faces.rows > 1)
    {
        // Retrieve boxes and scores
        std::vector<Rect2i> faceBoxes;
        std::vector<float> faceScores;
        for (int rIdx = 0; rIdx < faces.rows; rIdx++)
        {
            faceBoxes.push_back(Rect2i(int(faces.at<float>(rIdx, 0)),
                                        int(faces.at<float>(rIdx, 1)),
                                        int(faces.at<float>(rIdx, 2)),
                                        int(faces.at<float>(rIdx, 3))));
            faceScores.push_back(faces.at<float>(rIdx, 14));
        }

        std::vector<int> keepIdx;
        dnn::NMSBoxes(faceBoxes, faceScores, scoreThreshold, nmsThreshold, keepIdx, 1.f, topK);
        // printf("[%s()]::[%d] keepIdx: %d\n", __FUNCTION__, __LINE__, keepIdx);

        // Get NMS results
        for (int idx: keepIdx)
        {
            nms_faces.push_back(faces.row(idx));
        }
        // return nms_faces;
    }
    else
    {
        // return faces;
    }

    std::cout << cv::format("faces detected: %d \n", nms_faces.rows);

    for (int i = 0; i < nms_faces.rows; ++i)
    {
        int x1 = static_cast<int>(nms_faces.at<float>(i, 0));
        int y1 = static_cast<int>(nms_faces.at<float>(i, 1));
        int w = static_cast<int>(nms_faces.at<float>(i, 2));
        int h = static_cast<int>(nms_faces.at<float>(i, 3));
        float conf = nms_faces.at<float>(i, 14);
        // std::cout << cv::format("%d: x1=%d, y1=%d, w=%d, h=%d, conf=%.4f\n", i, x1, y1, w, h, conf);
    }

#endif

#if 1
    const char *input_img = NULL;
    const char result_img[256];
    // for testing
    input_img = 1;
    for (i = 0; i < input_num; i++)
    {
        input_img = inputs[i];
        printf("[%s()]::[%d] image_name = %s\n", __FUNCTION__, __LINE__, input_img);
    }
    cv::Mat image = cv::imread(input_img);
    auto res_image = visualize(image, nms_faces);
    sprintf(result_img, "result_%s", input_img);
    std::cout << "Results are saved to: " << result_img << std::endl;
    cv::imwrite(result_img, res_image);

#endif

final:
    return VSI_SUCCESS;
}

const vsi_nn_postprocess_map_element_t * vnn_GetPostProcessMap()
{
    return postprocess_map;
}

uint32_t vnn_GetPostProcessMapCount()
{
    if (postprocess_map == NULL)
       return 0;
    else
        return sizeof(postprocess_map) / sizeof(vsi_nn_postprocess_map_element_t);
}
